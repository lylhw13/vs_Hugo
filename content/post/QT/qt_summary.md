---
title: "Qt summary"
date: 2018-07-17T15:33:08+08:00
draft: true
tags: ["QT", "C++"]
categories: ["C++"]
---

# QT summary

QVector doesn't have range-construction.

更全面的分析如下<https://marcmutz.wordpress.com/effective-qt/containers/>

## snippets
    ```c++
    #include <QtWidgets/QApplication>
    #include <QtGui/QGuiApplication>
    ```
`QCoreApplication` is the base class, `QGuiApplication` extends the base class with functionality related to handling windows and GUI stuff (non-widget related, e.g. OpenGL or QtQuick), `QApplication` extends QGuiApplication with functionality related to handling widgets.

Each QML component is instantiated in a QQmlContext. QQmlContext's are essential for passing data to QML components. In QML, contexts are arranged hierarchically and this hierarchy is managed by the QQmlEngine.

- QQmlEngine
    - QQmlApplicationEngine
- QQmlComponent
- QQmlContext
## [QQmlEngine Class](https://doc.qt.io/qt-5/qqmlengine.html)
- The QQmlEngine class provides an environment for instantiating QML components.
- Each QML component is instantiated in a QQmlContext. QQmlContext's are essential for passing data to QML components. In QML, contexts are arranged hierarchically and this hierarchy is managed by the QQmlEngine.
- Prior to creating any QML components, an application must have created a QQmlEngine to gain access to a QML context.

## [QQmlApplicationEngine Class](https://doc.qt.io/qt-5/qqmlapplicationengine.html)
- QQmlApplicationEngine provides a convenient way to load an application from a single QML file.
- This class combines a QQmlEngine and QQmlComponent to provide a convenient way to load a single QML file. It also exposes some central application functionality to QML, which a C++/QML hybrid application would normally control from C++.
- Unlike QQuickView, QQmlApplicationEngine does not automatically create a root window. If you are using visual items from Qt Quick, you will need to place them inside of a Window.

## [QQmlComponent Class](https://doc.qt.io/qt-5/qqmlcomponent.html)
- The QQmlComponent class encapsulates a QML component definition.
- Components are reusable, encapsulated QML types with well-defined interfaces.
- A QQmlComponent instance can be created from a QML file.

## [QQmlContext Class](https://doc.qt.io/qt-5/qqmlcontext.html)
- The QQmlContext class defines a context within a QML engine.
- Contexts allow data to be exposed to the QML components instantiated by the QML engine.
- Each QQmlContext contains a set of properties, distinct from its QObject properties, that allow data to be explicitly bound to a context by name. 


- QQuickWiget
- QQuickItem
- QQuickView
## [QQuickWidget Class](https://doc.qt.io/qt-5/qquickwidget.html)
- Note: QQuickWidget is an alternative to using QQuickView and QWidget::createWindowContainer(). The restrictions on stacking order do not apply, making QQuickWidget the more flexible alternative, behaving more like an ordinary widget. This comes at the expense of performance. Unlike QQuickWindow and QQuickView, QQuickWidget involves rendering into OpenGL framebuffer objects. This will naturally carry a minor performance hit.
- Note: Using QQuickWidget disables the threaded render loop on all platforms. This means that some of the benefits of threaded rendering, for example Animator classes and vsync driven animations, will not be available.
- Note: Avoid calling winId() on a QQuickWidget. This function triggers the creation of a native window, resulting in reduced performance and possibly rendering glitches. The entire purpose of QQuickWidget is to render Quick scenes without a separate native window, hence making it a native widget should always be avoided. 

## [signals and slots](https://doc.qt.io/qt-5/signalsandslots.html)

### signals
- Signals are automatically generated by the moc and must not be implemented in the .cpp file. They can never have return types (i.e. use void).
### slots
- Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.
- There are several advantages to using QObject::connect() with function pointers. First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. Arguments can also be implicitly converted by the compiler, if needed.
- You should take care that any objects used inside the functor are still alive when the signal is emitted.
- The other way to connect a signal to a slot is to use QObject::connect() and the SIGNAL and SLOT macros. The rule about whether to include arguments or not in the SIGNAL() and SLOT() macros, if the arguments have default values, is that the signature passed to the SIGNAL() macro must not have fewer arguments than the signature passed to the SLOT() macro.


- [Positioning with Anchors](https://doc.qt.io/qt-5/qtquick-positioning-anchors.html)
- Qt Quick Layouts Overview



## commands

refer to [Prototyping with qmlscene](https://doc.qt.io/qt-5.9/qtquick-qmlscene.html)
```sh
qmlscene myqmlfile.qml
```


## fragmeny
```js
function createInput(num,x,y) {
    var component = Qt.createComponent("Test.qml")
    if(component.status === Component.Ready)
        component.createObject(addInput, {"x": x, "y": y})
    console.log("add a input " + y)
}
```

When referring to files stored with the Qt Resource System from within QML, you should use "qrc:///" instead of ":/" as QML requires URL paths. <https://doc.qt.io/qt-5/qml-url.html>

Since Qt Quick Layouts also resize their items, they are well suited for resizable user interfaces.<https://doc.qt.io/qt-5/qtquicklayouts-overview.html>


## model
If a C++ model class is used, it must be a subclass of QAbstractItemModel or a simple list.

<https://forum.qt.io/topic/68585/qabstractlistmodel-as-property>
QAbstractItemModel is a QObject subclass and thus by definition a non-copyable class.
You should return a pointer to a NoteList in your property.

## Registering Non-Instantiable Types
Sometimes a QObject-derived class may need to be registered with the QML type system but not as an instantiable type. For example, this is the case if a C++ class:

is an interface type that should not be instantiable
is a base class type that does not need to be exposed to QML
declares some enum that should be accessible from QML, but otherwise should not be instantiable
is a type that should be provided to QML through a singleton instance, and should not be instantiable from QML
The Qt QML module provides several methods for registering non-instantiable types:

qmlRegisterType() (with no parameters) registers a C++ type that is not instantiable and cannot be referred to from QML. This enables the engine to coerce any inherited types that are instantiable from QML.
qmlRegisterInterface() registers an existing Qt interface type. The type is not instantiable from QML, and you cannot declare QML properties with it. Using C++ properties of this type from QML will do the expected interface casts, though.
qmlRegisterUncreatableType() registers a named C++ type that is not instantiable but should be identifiable as a type to the QML type system. This is useful if a type's enums or attached properties should be accessible from QML but the type itself should not be instantiable.
qmlRegisterSingletonType() registers a singleton type that can be imported from QML, as discussed below.
## Row vs RowLayout
Row is [Item Positioners](https://doc.qt.io/qt-5/qtquick-positioning-layouts.html), RowLayout is [Qt Quick Layouts](https://doc.qt.io/qt-5/qtquicklayouts-index.html). 

They behave in a similar way, but have two difference:

- Item Positioners are also containers in their own right.
- Qt Quick Layouts can resize their items.

## [splitview](https://doc.qt.io/qt-5/qml-qtquick-controls-splitview.html)
There will always be one (and only one) item in the SplitView that has Layout.fillWidth set to true
