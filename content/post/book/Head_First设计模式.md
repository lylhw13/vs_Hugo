---
title: "Head_First设计模式"
date: 2019-07-08T16:36:10+08:00
draft: true
---

# 设计原则：
找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

把会变化的部分取出并封装起来，以便以后可以轻易地改变或扩充此部分，而不影响不需要变化的其他部分。

`针对接口编程，而不是针对实现编程。`

多用组合，少用继承

# 设计模式：
## 策略模式 (Strategy Pattern)
定义：
策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式算法的变化独立于使用算法的客户。

设计模式让你和其他开发人员之间有共享的词汇，用更少的词汇做更有效的沟通。设计模式也可以把你的思考架构的层次提高到模式层面，而不是仅停留在琐碎的对象上。

模式被认为是历经验证的OO设计经验，模式不是被发明而是被发现。

## 观察者模式 (Observer Pattern)

观察者模式是JDK中使用最多的模式之一。

定义：
观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。

Subject 主题; Observer 观察者

观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

不要依赖于观察者被通知的次序

使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更正确).

有多个观察者时，不可以依赖特定的通知顺序。

## 装饰者模式

设计原则：类应该对扩展开放，对修改关闭

装饰者可以在所委托被装饰者对行为之前与/或之后，加上自己对行为，一达到特定对目的。

定义：

装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性对替代方案。

装饰者和被装饰者必须是一样的类型，也就是有共同的超类。

利用装饰者模式，常常造成设计中有大量的小类。

## 工厂方法模式 Factory Method Pattern

简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。

工厂方法模式通过让子类决定创建的对象是什么，来达到将对象创建的过程封装的目的。

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

### 设计原则

依赖倒置原则 (Dependency Inversion Principle) 要依赖抽象，不要依赖具体类。

- 变量不可以持有具体类的引用
- 不要让类派生自具体类
- 不要覆盖基类中已实现的方法

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

## 单件模式 Singleton Pattern

引用一个静态方法，需要使用类名。

定义：
单件模式确保一个类只有一个实例，并提供一个全局访问点。

除非有绝对的必要使用类的单件，否则还是建议使用对象的单件，比较保险。

在Java中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。

## 命令模式

命令模式将“请求”封装成对象，以便使用不同对请求、队列或者日志参数化其他对象。命令模式也支持可撤销的操作。

在许多设计模式中，都会看到空对象(null object)的使用。甚至有些时候，空对象本身也被视为是一种设计模式。

命令可以将运算块打包（一个接受者和一组动作）

## 适配器模式与外观模式 (Facade Pattern)

适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容对类可以合作无间。

适配器模式有两种形式：对象适配器和类适配器。
类适配器不是使用组合来适配被适配者，而是继承被适配者和目标类。而对象适配器利用组合对方式将请求传给被适配者。

外观不只是简化了接口，也将客户从组件对子系统中解耦。

外观和适配器可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同接口。

- 适配器将一个对象包装起来以改变其接口；
- 装饰者将一个对象包装起来以增加新的行为和责任；
- 外观将一群对象“包装”起来以简化其接口。

外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

最少知识（Least Knowledge）原则告诉我们要减少对象之间的交互，只留下几个“密友”。
最少知识原则：只和你的密友谈话。

## 模版方法模式
封装算法

模版方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。

模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

模版方法的抽象类可以定义具体方法、抽象方法和钩子。

为了防止子类改变模版方法中的算法，可以将模版方法声明为final。

钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行觉定。

好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。
好莱坞原则可以给我们一种防止“依赖腐败”的方法。
底层组件在结束时，常常会调用从超类中继承来的方法。我们要做但是，避免让高层和低层组件之间有明显的环状依赖。
将决策权放在高层模块中，以便决定如何以及何时调用低层模块。

好莱坞原则和依赖倒置原则之间的关系？
依赖倒置原则教我们尽量避免使用具体类，而多使用抽象。而好莱坞原则是用在创建框架或组件上的一种技巧，好让底层组件能够被挂钩进计算中，而且又不会让高层组件依赖低层组件。两者的目标都是在于解耦。

策略模式和模版方法模式都封装算法，一个用组合，一个用继承。
工厂方法是模版方法的一个特殊版本。

## 迭代器与组合模式
管理良好的集合

迭代器模式(Iterator Pattern): 提供一种方法访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

迭代器意味着没有次序。

设计原则：一个类应该只有一个引起变化的原因

内聚(cohesion)用来度量一个类或模块紧密地达到单一目的或责任。

组合模式(Composite Pattern): 允许你将对象组合成树形结构来表现"整体/部分"层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

组合模式以单一责任设计原则换取透明性(transparency)。

组合迭代器(CompositeIterator)
空迭代器(NullIterator)

## 状态模式
事物的状态

状态机(state machine)

状态模式：允许对象在内部状态改变是改变它的行为，对象看起来好像修改了它的类。

这个模式将状态封装成独立的类，并将动作委托到代表当前状态的对象上。

## 代理模式
控制对象访问

代理模式: 为另一个对象提供一个替身或占位符以控制对这个对象的访问。

## 复合模式

设计模式是MVC的钥匙

Model - View - Controller

MVC是复合模式，结合了观察者模式、策略模式和组合模式。
- 模型使用观察者模式，以便观察者更新，同时保持两者之间的解耦。
- 控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为。
- 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，像面板、框架和按钮。

这些模式携手合作，把MVC模型的三层解耦，这样可以保持设计干净又有弹性。

适配器模式用来将新的模式适配成已有的视图和控制器。

Model 2 是MVC在wed上的应用，在Model 2中，控制器实现成Servlet，而JSP/HTML实现成视图。

控制器为视图实现行为，将来自视图的动作转成模型上的动作。
模型实现应用逻辑，并决定如何响应动作。

## 与设计模式相处

模式是在某情境(context)下，针对某问题的某种解决方案。

模式是工具而不是规则，需要被适当地调整以符合需求。

总是使用满足需求的最简单解决方案，不管它用不用模式。

模式能够带来的最大好处之一是：让你的团队拥有共享词汇。

桥接
使用桥接(Bridge Pattern)不只改变你的实现，也改变你的抽象。

生成器模式（Builder Pattern）

责任链模式（Chain of Responsibility Pattern）

蝇量模式（Flyweight Pattern）

解释器模式 Interpreter Pattern

中介者模式 Mediator Pattern

备忘录模式 MementoPattern

原型模式 Prototype Pattern

访问者模式 Visitor Pattern

