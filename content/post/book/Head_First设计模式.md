---
title: "Head_First设计模式"
date: 2019-07-08T16:36:10+08:00
draft: true
---

# 设计原则：
找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

把会变化的部分取出并封装起来，以便以后可以轻易地改变或扩充此部分，而不影响不需要变化的其他部分。

针对接口编程，而不是针对实现编程。

多用组合，少用继承

# 设计模式：
## 策略模式 (Strategy Pattern)
定义：
策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式算法的变化独立于使用算法的客户。

设计模式让你和其他开发人员之间有共享的词汇，用更少的词汇做更有效的沟通。设计模式也可以把你的思考架构的层次提高到模式层面，而不是仅停留在琐碎的对象上。

模式被认为是历经验证的OO设计经验，模式不是被发明而是被发现。

## 观察者模式 (Observer Pattern)

观察者模式是JDK中使用最多的模式之一。

定义：
观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。

Subject 主题; Observer 观察者

观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

不要依赖于观察者被通知的次序

使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更正确).

有多个观察者时，不可以依赖特定的通知顺序。

## 装饰者模式

设计原则：类应该对扩展开放，对修改关闭

装饰者可以在所委托被装饰者对行为之前与/或之后，加上自己对行为，一达到特定对目的。

定义：

装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性对替代方案。

装饰者和被装饰者必须是一样的类型，也就是有共同的超类。

利用装饰者模式，常常造成设计中有大量的小类。

## 工厂方法模式 Factory Method Pattern

简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。

工厂方法模式通过让子类决定创建的对象是什么，来达到将对象创建的过程封装的目的。

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

### 设计原则

依赖倒置原则 (Dependency Inversion Principle) 要依赖抽象，不要依赖具体类。

- 变量不可以持有具体类的引用
- 不要让类派生自具体类
- 不要覆盖基类中已实现的方法

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

## 单件模式 Singleton Pattern

引用一个静态方法，需要使用类名。

定义：
单件模式确保一个类只有一个实例，并提供一个全局访问点。

除非有绝对的必要使用类的单件，否则还是建议使用对象的单件，比较保险。

在Java中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。

## 命令模式


