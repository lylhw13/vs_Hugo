---
title: "Fluent_python"
date: 2019-06-13T19:11:22+08:00
draft: true
---
## chapter 3

原子不可变数据类型（str、bytes 和数值类型）都是可散列类
型，frozenset 也是可散列的，因为根据其定义，frozenset 里
只能容纳可散列类型。元组的话，只有当一个元组包含的所有元素
都是可散列类型的情况下，它才是可散列的。

## chapter 7

闭包关键是它能不能访问定义体之外的非全局变量。

综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

但是对数字、字符串、元组等不可变类型来说，只能读取，不能更新。
如果尝试重新绑定，例如 count = count + 1，其实会隐式创建局部
变量 count。这样，count 就不是自由变量了，因此不会保存在闭包
中。

标准库中最值得关注的两个
装饰器是 lru_cache 和全新的 singledispatch（Python 3.4 新增）。

LRU 三个字母是“Least
Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存
条目会被扔掉。

只要可能，注册的专门函数应该处理抽象基类（如 numbers.Integral
和 abc.MutableSequence），不要处理具体实现（如 int 和
list）。这样，代码支持的兼容类型更广泛。例如，Python 扩展可以子
类化 numbers.Integral，使用固定的位数实现 int 类型。

@register 工厂函数必须作为函数调用，并且传入所需的参数。即使不传入参数，register 也必须作为函数调用

## chapter 8
== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的
标识。

元组与多数 Python 集合（列表、字典、集，等等）一样，保存的是对象
的引用。 如果引用的元素是可变的，即便元组本身不可变，元素依然
可变。也就是说，元组的不可变性其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。

而 str、bytes 和 array.array 等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内存中保存数据本身（字符、字节和数字）。

Python 唯一支持的参数传递模式是共享传参（call by sharing）。
共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是
说，函数内部的形参是实参的别名。

del 语句删除名称，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。

Python 控制台会自动把 _ 变量绑定到结果不为 None 的表达式结果上。

共享字符串字面量是一种优化措施，称为驻留（interning）。千万不要依赖字符串或整数的驻留！比较字符串或整数是否相等时，应该使用 ==，而不是 is。驻留是 Python 解释器内部使用的一个特性。

对 += 或 *= 所做的增量赋值来说，如果左边的变量绑定的是不可变
对象，会创建新对象；如果是可变对象，会就地修改。

## chapter 9

在 Python 3中，__repr__、__str__ 和 __format__ 都必须返回 Unicode 字符串（str 类型）。只有 __bytes__ 方法应该返回字节序列（bytes 类型）。

 classmethod。示例 9-3 展示了它的用法：定义操作类，而不是
操作实例的方法。classmethod 改变了调用方法的方式，因此类方法
的第一个参数是类本身，而不是实例。classmethod 最常见的用途是
定义备选构造方法，

要想创建可散列的类型，不一定要实现特性，也不一定要保
护实例属性。只需正确地实现 __hash__ 和 __eq__ 方法即可。但
是，实例的散列值绝不应该变化，因此我们借机提到了只读特性。

如果以 __mood 的形式（两个前导下划线，尾部没
有或最多有一个下划线）命名实例属性，Python 会把属性名存入实例的
__dict__ 属性中，而且会在前面加上一个下划线和类名。因此，对
Dog 类来说，__mood 会变成 _Dog__mood；对 Beagle 类来说，会变成
_Beagle__mood。这个语言特性叫名称改写（name mangling）。