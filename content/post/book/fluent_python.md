---
title: "Fluent_python"
date: 2019-06-13T19:11:22+08:00
draft: true
---

## chapter 2

容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列
里存放的是值而不是引用。换句话说，扁平序列其实是一段连续的内存
空间。由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字
符、字节和数值这种基础类型。

Python 会忽略代码里 []、{} 和 () 中的换行，因此如果你的代码里有多行的列表、列表推导、生成器表达式、字典这一类的，可以省
略不太好看的续行符 \。

还可以用 * 运算符把一个可迭代对象拆开作为函数的参数

在平行赋值中，* 前缀只能用在一个变量名前面，但是这个变量可以出
现在赋值表达式的任意位置

用 namedtuple 构建的类的实例所消耗的内存跟元组是一样
的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实
例比起来也要小一些，因为 Python 不会用 __dict__ 来存放这些实
例的属性。

Python 内置的序列类型都是一维的，因此它们只支持单一的索引，成对出现的索引是没有用的。

省略（ellipsis）的正确书写方法是三个英语句号（...），而不是
Unicdoe 码位 U+2026 表示的半个省略号（...）。

如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代
对象。

list.sort 方法会就地排序列表，也就是说不会把原列表复制一份。这也是这个方法的返回值是 None 的原因，提醒你本方法不会新建一个列表。在这种情况下返回 None 其实是 Python 的一个惯例：如果一个函数或者方法对对象进行的是就地改动，那它就应该返回 None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。

与 list.sort 相反的是内置函数 sorted，它会新建一个列表作为返回
值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可
变序列或生成器（见第 14 章）。而不管 sorted 接受的是怎样的参
数，它最后都会返回一个列表。

数组在背后存的并不是 float 对象，而是数字的机器翻
译，也就是字节表述。这一点就跟 C 语言中的数组一样。

## chapter 3

原子不可变数据类型（str、bytes 和数值类型）都是可散列类
型，frozenset 也是可散列的，因为根据其定义，frozenset 里
只能容纳可散列类型。元组的话，只有当一个元组包含的所有元素
都是可散列类型的情况下，它才是可散列的。

## chapter 7

闭包关键是它能不能访问定义体之外的非全局变量。

综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

但是对数字、字符串、元组等不可变类型来说，只能读取，不能更新。
如果尝试重新绑定，例如 count = count + 1，其实会隐式创建局部
变量 count。这样，count 就不是自由变量了，因此不会保存在闭包
中。

标准库中最值得关注的两个
装饰器是 lru_cache 和全新的 singledispatch（Python 3.4 新增）。

LRU 三个字母是“Least
Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存
条目会被扔掉。

只要可能，注册的专门函数应该处理抽象基类（如 numbers.Integral
和 abc.MutableSequence），不要处理具体实现（如 int 和
list）。这样，代码支持的兼容类型更广泛。例如，Python 扩展可以子
类化 numbers.Integral，使用固定的位数实现 int 类型。

@register 工厂函数必须作为函数调用，并且传入所需的参数。即使不传入参数，register 也必须作为函数调用

## chapter 8
== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的
标识。

元组与多数 Python 集合（列表、字典、集，等等）一样，保存的是对象
的引用。 如果引用的元素是可变的，即便元组本身不可变，元素依然
可变。也就是说，元组的不可变性其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。

而 str、bytes 和 array.array 等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内存中保存数据本身（字符、字节和数字）。

Python 唯一支持的参数传递模式是共享传参（call by sharing）。
共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是
说，函数内部的形参是实参的别名。

del 语句删除名称，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。

Python 控制台会自动把 _ 变量绑定到结果不为 None 的表达式结果上。

共享字符串字面量是一种优化措施，称为驻留（interning）。千万不要依赖字符串或整数的驻留！比较字符串或整数是否相等时，应该使用 ==，而不是 is。驻留是 Python 解释器内部使用的一个特性。

对 += 或 *= 所做的增量赋值来说，如果左边的变量绑定的是不可变
对象，会创建新对象；如果是可变对象，会就地修改。

## chapter 9

在 Python 3中，__repr__、__str__ 和 __format__ 都必须返回 Unicode 字符串（str 类型）。只有 __bytes__ 方法应该返回字节序列（bytes 类型）。

 classmethod。示例 9-3 展示了它的用法：定义操作类，而不是
操作实例的方法。classmethod 改变了调用方法的方式，因此类方法
的第一个参数是类本身，而不是实例。classmethod 最常见的用途是
定义备选构造方法，

要想创建可散列的类型，不一定要实现特性，也不一定要保
护实例属性。只需正确地实现 __hash__ 和 __eq__ 方法即可。但
是，实例的散列值绝不应该变化，因此我们借机提到了只读特性。

如果以 __mood 的形式（两个前导下划线，尾部没
有或最多有一个下划线）命名实例属性，Python 会把属性名存入实例的
__dict__ 属性中，而且会在前面加上一个下划线和类名。因此，对
Dog 类来说，__mood 会变成 _Dog__mood；对 Beagle 类来说，会变成
_Beagle__mood。这个语言特性叫名称改写（name mangling）。

## chapter 16

从根本上把yield视做控制流程的方式，这样就好理解协程了。
协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。

关键的一点是，协程在 yield 关键字所在的位置暂停执行。前面说
过，在赋值语句中，= 右边的代码在赋值之前执行。因此，对于 b =
yield a 这行代码来说，等到客户端代码再激活协程时才会设定 b 的
值。

使用协程之前必须预激，可是这一步容易忘记。为了避免忘记，可以在协程上使用一个
特殊的装饰器。

使用 yield from 句法（参见 16.7 节）调用协程时，会自动预激，因
此与示例 16-5 中的 @coroutine 等装饰器不兼容。Python 3.4 标准库里
的 asyncio.coroutine 装饰器（第 18 章介绍）不会预激协程，因此
能兼容 yield from 句法。

离散事件仿真（Discrete Event Simulation，DES）

## chapter 17
GIL（Global Interpreter
Lock，全局解释器锁）

CPython 解释器本身就不是线程安全的，因此有全局解释器锁（GIL），
一次只允许使用一个线程执行 Python 字节码。因此，一个 Python 进程
通常不能同时使用多个 CPU 核心

## chapter 19

我们要记住重要的一点，仅当无法使用常规的方
式获取属性（即在实例、类或超类中找不到指定的属性），解释器才会
调用特殊的 __getattr__ 方法。
## chapter 11

__mro__ Method Resolution Order 方法解析顺序

强类型和弱类型：
    如果一门语言很少隐式转换类型，说明它是强类型语言；如果经常这么做，说明它是弱类型语言。Java，C++和Python是强类型语言。PHP，JavaScript和Perl是弱类型语言。

## chapter 12
优先使用对象组合，而不是类继承。

## chapter 13
~(__invert__)  ~x == -(x+1)
