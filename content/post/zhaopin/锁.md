---
title: "锁"
date: 2020-08-09T19:25:41+08:00
draft: true
---
参考：https://juejin.im/post/6844903639207641096

# 何谓悲观锁与乐观锁

- 悲观锁
    每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
- 乐观锁
    每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。


## 使用场景
两种锁各有优缺点，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。
但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

## 乐观锁常见的两种实现方式
乐观锁一般会使用版本号机制或CAS算法实现。

1. 版本号机制
一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

2. CAS算法
即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

需要读写的内存值 V
进行比较的值 A
拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

## 乐观锁的缺点
1. ABA 问题
    如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。
2. 循环时间长开销大
    自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 
3. 只能保证一个共享变量的原子操作
    CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。


# 读写锁 读者写者问题
读者写者问题的解决方案一般都有两种不同的侧重：读者优先或者写者优先。

- 读者优先就是尽量满足并发的读操作，当已经有线程在读数据的时候，其他读线程无需等待，而写线程需要等待所有正在进行的读操作之后才能执行。
- 写者优先就是尽量满足写操作，尽管写操作不能并发，但是可以排队，优先于等待的读线程获得执行权。

读者优先:
1.写者、读者互斥访问文件资源。
2.多个读者可以同时访问文件资源。
3.只允许一个写者访问文件资源。

写者优先:
1.写者线程的优先级高于读者线程。
2.当有写者到来时应该阻塞读者线程的队列。
3.当有一个写者正在写时或在阻塞队列时应当阻塞读者进程的读操作，直到所有写者进程完成写操作时放开读者进程。
4.当没有写者进程时读者进程应该能够同时读取文件。

公平竞争：
1.优先级相同。
2.写者、读者互斥访问。
3.只能有一个写者访问临界区。
4.可以有多个读者同时访问临界资源。