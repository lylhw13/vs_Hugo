---
title: "Qt"
date: 2020-08-18T16:56:10+08:00
draft: true
---

QProcess
QProcess allows you to treat a process as a sequential I/O device. You can write to and read from the process just as you would access a network connection using QTcpSocket. 

# 信号槽
本质是：回调函数
优势：
1. 类型安全。需要关联的信号和槽的签名必须是等同的，即信号的参数类型和参数个数同接收该信号的槽的参数类型和参数个数相同。不过，一个槽的参数个数是可以少于信号的参数个数的，但缺少的参数必须是信号参数的最后一个或几个参数。如果信号和槽的签名不符，编译器就会报错。
2. 松散耦合。信号和槽机制减弱了Qt对象的耦合度。激发信号的Qt对象无需知道是哪个对象的哪个槽需要接收它发出的信号，它只需在适当的时间发送适当的信号就可以了，而不需要知道也不关心它的信号有没有被接收到，更不需要知道是哪个对象的哪个槽收到了信号。同样的，对象的槽也不知道是哪些信号关联了自己，而一旦关联信号和槽，Qt就保证了适合的槽得到了调用。即使关联的对象在运行时被删除，应用程序也不会崩溃。
3. 信号和槽机制增强了对象间通信的灵活性。一个信号可以关联多个槽，也可以多个信号关联一个槽。

# Qt信号槽机制的不足
同回调函数相比，信号和槽机制运行速度有些慢。通过传递一个信号来调用槽函数将会比直接调用非虚函数运行速度慢10倍。原因如下：
1. 需要定位接收信号的对象；
2. 安全地遍历所有的关联（如一个信号关联多个槽的情况）；
3. 编组/解组传递的参数；
4. 多线程的时候，信号可能需要排队等待。
然而，与创建对象的new操作及删除对象的delete操作相比，信号和槽的运行代价只是他们很少的一部分。信号和槽机制导致的这点性能损耗，对实时应用程序是可以忽略的。

# 描述Qt下Tcp通信的整个流程
服务器端:
1. 创建用于监听的套接字
2. 给套接字设置监听
3. 如果有连接到来, 监听的套接字会发出信号newConnected
4. 接收连接, 通过nextPendingConnection()函数, 返回一个QTcpSocket类型的套接字对象(用于通信)
5. 使用用于通信的套接字对象通信
1>. 发送数据: write
2>. 接收数据: readAll/read
客户端:
1. 创建用于通信的套接字
2. 连接服务器: connectToHost
3. 连接成功与服务器通信
1>. 发送数据: write
2>. 接收数据: readAll/read

# 描述QT下udp通信的整个流程
QT下udp通信服务器端和客户端的关系是对等的, 做的处理也是一样的.
1. 创建套接字对象
2. 如果需要接收数据, 必须绑定端口
3. 发送数据: writeDatagram
4. 接收数据: readDatagram

# 多线程下，信号槽分别在什么线程中执行，如何控制

可以通过connect的第五个参数进行控制信号槽执行时所在的线程
connect有几种连接方式，直接连接和队列连接、自动连接
- 直接连接：信号槽在信号发出者所在的线程中执行
- 队列连接：信号在信号发出者所在的线程中执行，槽函数在信号接收者所在的线程中执行
- 自动连接：多线程时为队列连接函数，单线程时为直接连接函数。