---
title: "Linux"
date: 2020-06-14T15:01:45+08:00
draft: true
---


“文件”本质就是一种抽象，可以使用同一套api(read, write)和工具(cat , 重定向, 管道)来处理unix中大多数的资源.

线程vs进程

Linux_UNIX系统编程手册 page547

用户线程和内核线程

内核线程
内核线程又称为守护进程，内核线程的调度由内核负责，一个内核线程处于阻塞状态时不影响其他的内核线程，因为其是调度的基本单位。这与用户线程是不一样的；
这些线程可以在全系统内进行资源的竞争；
内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制。在一定程度上类似于进程，只是创建、调度的开销要比进程小。有的统计是1：10。
内核线程切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态，即存在用户态和内核态之间的转换，比如多核cpu，还有win线程的实现。

用户线程
用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程（用户进程）本身，内核并不能看到用户线程，内核并不知道用户线程的存在。
不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。
内核资源的分配仍然是按照进程（用户进程）进行分配的；各个用户线程只能在进程内进行资源竞争。
用户级线程内核的切换由用户态程序自己控制内核切换（通过系统调用来获得内核提供的服务）,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。目前Linux pthread大体是这么做的。
每个用户线程并不具有自身的线程上下文。因此，就线程的同时执行而言，任意给定时刻每个进程只能够有一个线程在运行，而且只有一个处理器内核会被分配给该进程。


实际上I/O多路复用，信号驱动I/O以及epoll都用来实现同一个目标技术-同时检查多个文件描述符，看它们是否准备好了执行I/O操作（准确的说，是看I/O系统调用是否可以非阻塞地执行。


本文将介绍 Linux 执行系统调用的三种方法：
- 使用软件中断（Software interrupt）触发系统调用；
- 使用 SYSCALL / SYSENTER 等汇编指令触发系统调用；
- 使用虚拟动态共享对象（virtual dynamic shared object、vDSO）执行系统调用；

# 处理程序时开启多少并发线程最合适？

首先要考虑执行的任务是什么类型：
1、IO密集型
2、计算密集型

IO密集型：以大量任务读写数据库，读写文件为主，内存中的运算很少，线程基本阻塞在IO上面。这种情况下，尽量多开启一些线程并发做IO操作，因为在IO过程中，CPU几乎是闲置的。
计算密集型：任务以内存中的计算为主。这时候CPU是满负荷工作，即使开再多的线程，只会徒增线程上下午切换的成本。这种情况下，CPU是几核，就开几个线程。

线程数 = (IO时间 + CPU工作时间) / CPU工作时间 * 核数

IO密集型，相当于CPU工作时间无穷小的情况，这时候得到的线程数很大。
计算密集型，相当于IO时间无穷小，计算得的线程数约等于CPU核数。

# 查看某个端口被占用
```sh
lsof -i

netstat -anp | grep 80
```

# 抢占式内核与非抢占式内核的区别

- 内核抢占（可抢占式内核）：
即当进程位于内核空间时，有一个更高优先级的任务出现时，如果当前内核允许抢占，则可以将当前任务挂起，执行优先级更高的进程。
- 非抢占式内核：
高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占CPU运行。进程一旦处于核心态(例如用户进程执行系统调用)，则除非进程自愿放弃CPU，否则该进程将一直运行下去，直至完成或退出内核。

抢占式内核的意义：
    实时系统对响应时间有严格的限定，当一个实时进程被实时设备的硬件中断唤醒后，它应在限定的时间内被调度执行。而Linux不能满足这一要求，因为Linux的内核是不可抢占的，不能确定系统在内核中的停留时间。事实上当内核执行长的系统调用时，实时进程要等到内核中运行的进程退出内核才能被调度，由此产生的响应延迟，在如今的硬件条件下，会长达100ms级。这对于那些要求高实时响应的系统是不能接受的。


# 生产者，消费者

生产者 - 消费者（Producer-Consumer），也叫有限缓冲（Bounded-Buffer），是多线程同步的经典问题之一。


# 进程间通信方式
进程间通信（IPC，InterProcess Communication）
1. 管道/匿名管道(pipe)
2. 有名管道(FIFO)
3. 信号(Signal)
4. 消息(Message)队列：消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
5. 共享内存(share memory)
6. 信号量(semaphore)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
7. 套接字(socket)

# 线程的五种状态

任何线程一般具有五种状态，即创建、就绪、运行、阻塞、终止。

当线程启动时，线程进入就绪状态（runnable）。
阻塞被消除后是回到就绪状态，不是运行状态。

# 阻塞型和非阻塞型文件描述符，都能用epoll的LT和ET模式吗？

阻塞不能用ET，非阻塞都可以。

边缘触发通知ET 通常和非阻塞的文件描述符结合使用。
两点原因：
1. 在接收到一个I/O 事件通知时，程序在某个时刻应该在相应的文件描述符上尽可能多地执行I/O。如果程序没有这么做，那么就可能失去执行I/O的机会。因为直到产生另外一个I/O事件为止，在此之前程序都不会再接收到通知，因此也就不知道应该执行I/O操作。这将导致数据丢失或者程序中出现阻塞。
2. 如果程序采用循环来对文件描述符执行尽可能多的I/O，而文件描述符又被置为可阻塞的，那么最终当没有更多的I/O执行时，I/O系统调用就会阻塞。基于这个原因，每个被检查的文件描述符通常都应该设置为非阻塞模式。


