---
title: "Linux"
date: 2020-06-14T15:01:45+08:00
draft: true
---


“文件”本质就是一种抽象，可以使用同一套api(read, write)和工具(cat , 重定向, 管道)来处理unix中大多数的资源.

线程vs进程

Linux_UNIX系统编程手册 page547

用户线程和内核线程

内核线程
内核线程又称为守护进程，内核线程的调度由内核负责，一个内核线程处于阻塞状态时不影响其他的内核线程，因为其是调度的基本单位。这与用户线程是不一样的；
这些线程可以在全系统内进行资源的竞争；
内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制。在一定程度上类似于进程，只是创建、调度的开销要比进程小。有的统计是1：10。
内核线程切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态，即存在用户态和内核态之间的转换，比如多核cpu，还有win线程的实现。

用户线程
用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程（用户进程）本身，内核并不能看到用户线程，内核并不知道用户线程的存在。
不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。
内核资源的分配仍然是按照进程（用户进程）进行分配的；各个用户线程只能在进程内进行资源竞争。
用户级线程内核的切换由用户态程序自己控制内核切换（通过系统调用来获得内核提供的服务）,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。目前Linux pthread大体是这么做的。
每个用户线程并不具有自身的线程上下文。因此，就线程的同时执行而言，任意给定时刻每个进程只能够有一个线程在运行，而且只有一个处理器内核会被分配给该进程。


实际上I/O多路复用，信号驱动I/O以及epoll都用来实现同一个目标技术-同时检查多个文件描述符，看它们是否准备好了执行I/O操作（准确的说，是看I/O系统调用是否可以非阻塞地执行。


本文将介绍 Linux 执行系统调用的三种方法：
- 使用软件中断（Software interrupt）触发系统调用；
- 使用 SYSCALL / SYSENTER 等汇编指令触发系统调用；
- 使用虚拟动态共享对象（virtual dynamic shared object、vDSO）执行系统调用；

# 处理程序时开启多少并发线程最合适？

首先要考虑执行的任务是什么类型：
1、IO密集型
2、计算密集型

IO密集型：以大量任务读写数据库，读写文件为主，内存中的运算很少，线程基本阻塞在IO上面。这种情况下，尽量多开启一些线程并发做IO操作，因为在IO过程中，CPU几乎是闲置的。
计算密集型：任务以内存中的计算为主。这时候CPU是满负荷工作，即使开再多的线程，只会徒增线程上下午切换的成本。这种情况下，CPU是几核，就开几个线程。

线程数 = (IO时间 + CPU工作时间) / CPU工作时间 * 核数

IO密集型，相当于CPU工作时间无穷小的情况，这时候得到的线程数很大。
计算密集型，相当于IO时间无穷小，计算得的线程数约等于CPU核数。