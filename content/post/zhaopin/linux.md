---
title: "Linux"
date: 2020-06-14T15:01:45+08:00
draft: true
---


“文件”本质就是一种抽象，可以使用同一套api(read, write)和工具(cat , 重定向, 管道)来处理unix中大多数的资源.

线程vs进程

Linux_UNIX系统编程手册 page547

用户线程和内核线程

内核线程
内核线程又称为守护进程，内核线程的调度由内核负责，一个内核线程处于阻塞状态时不影响其他的内核线程，因为其是调度的基本单位。这与用户线程是不一样的；
这些线程可以在全系统内进行资源的竞争；
内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制。在一定程度上类似于进程，只是创建、调度的开销要比进程小。有的统计是1：10。
内核线程切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态，即存在用户态和内核态之间的转换，比如多核cpu，还有win线程的实现。

用户线程
用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程（用户进程）本身，内核并不能看到用户线程，内核并不知道用户线程的存在。
不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。
内核资源的分配仍然是按照进程（用户进程）进行分配的；各个用户线程只能在进程内进行资源竞争。
用户级线程内核的切换由用户态程序自己控制内核切换（通过系统调用来获得内核提供的服务）,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。目前Linux pthread大体是这么做的。
每个用户线程并不具有自身的线程上下文。因此，就线程的同时执行而言，任意给定时刻每个进程只能够有一个线程在运行，而且只有一个处理器内核会被分配给该进程。


实际上I/O多路复用，信号驱动I/O以及epoll都用来实现同一个目标技术-同时检查多个文件描述符，看它们是否准备好了执行I/O操作（准确的说，是看I/O系统调用是否可以非阻塞地执行。


本文将介绍 Linux 执行系统调用的三种方法：
- 使用软件中断（Software interrupt）触发系统调用；
- 使用 SYSCALL / SYSENTER 等汇编指令触发系统调用；
- 使用虚拟动态共享对象（virtual dynamic shared object、vDSO）执行系统调用；

# 查看某个端口被占用
```sh
lsof -i

netstat -anp | grep 80
```

# 抢占式内核与非抢占式内核的区别

- 内核抢占（可抢占式内核）：
即当进程位于内核空间时，有一个更高优先级的任务出现时，如果当前内核允许抢占，则可以将当前任务挂起，执行优先级更高的进程。
- 非抢占式内核：
高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占CPU运行。进程一旦处于核心态(例如用户进程执行系统调用)，则除非进程自愿放弃CPU，否则该进程将一直运行下去，直至完成或退出内核。

抢占式内核的意义：
    实时系统对响应时间有严格的限定，当一个实时进程被实时设备的硬件中断唤醒后，它应在限定的时间内被调度执行。而Linux不能满足这一要求，因为Linux的内核是不可抢占的，不能确定系统在内核中的停留时间。事实上当内核执行长的系统调用时，实时进程要等到内核中运行的进程退出内核才能被调度，由此产生的响应延迟，在如今的硬件条件下，会长达100ms级。这对于那些要求高实时响应的系统是不能接受的。


# 进程间通信方式
进程间通信（IPC，InterProcess Communication）
1. 管道/匿名管道(pipe)
2. 有名管道(FIFO)
3. 信号(Signal)
4. 消息(Message)队列：消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
5. 共享内存(share memory)
6. 信号量(semaphore)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
7. 套接字(socket)

# 线程间通信方式
1. 互斥锁
2. 条件变量
3. 信号量

# 线程的五种状态

任何线程一般具有五种状态，即创建、就绪、运行、阻塞、终止。

当线程启动时，线程进入就绪状态（runnable）。
阻塞被消除后是回到就绪状态，不是运行状态。

# 阻塞型和非阻塞型文件描述符，都能用epoll的LT和ET模式吗？

阻塞不能用ET，非阻塞都可以。

边缘触发通知ET 通常和非阻塞的文件描述符结合使用。
两点原因：
1. 在接收到一个I/O 事件通知时，程序在某个时刻应该在相应的文件描述符上尽可能多地执行I/O。如果程序没有这么做，那么就可能失去执行I/O的机会。因为直到产生另外一个I/O事件为止，在此之前程序都不会再接收到通知，因此也就不知道应该执行I/O操作。这将导致数据丢失或者程序中出现阻塞。
2. 如果程序采用循环来对文件描述符执行尽可能多的I/O，而文件描述符又被置为可阻塞的，那么最终当没有更多的I/O执行时，I/O系统调用就会阻塞。基于这个原因，每个被检查的文件描述符通常都应该设置为非阻塞模式。


# 五种IO模型？

- 阻塞（blocking）
- 非阻塞（non-blocking）
- IO复用（IO multiplexing）
- 信号驱动（signal-driven）
- 异步（asynchronous）

# pthread_detach和pthread_join的作用

join两个作用：
- 等待线程终止
- 返回其终止状态

函数 pthread_join() 等待由 thread标示的线程终止。如果线程已终止，pthread_join() 会立即返回。这种操作被称为连接（joining）。
默认情况下，线程是可连接的（joinable），也就是说，当线程退出时，其他线程可以通过调用pthread_join() 获取其返回状态。
若不关心线程的返回状态，只是希望系统在线程终止时能自动清理并移除之。
一旦线程处于分离状态，就不能再使用pthread_join()来获取其状态，也无法使其重返“可连接”的状态。

# 守护线程
守护进程（daemon）是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。UNIX系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾。

# 僵尸进程和孤儿进程

- 孤儿进程：一个其父进程已终止的进程称为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

- 僵尸进程：一个进程使用fork创建子进程，如果在子进程退出之前，其父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

# linux下把进程/线程绑定到特定cpu核上运行

- 进程
    1. 在shell中将为进程指定CPU，使用taskset工具。
    2. 使用`sched_setaffinity`系统调用将某个进程绑定到特定的CPU。
```
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <sched.h>

int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);

int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);
```

- 线程
    使用`pthread_setaffinity_np`函数将指定线程绑定到特定的CPU运行。
```
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <pthread.h>

int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);
int pthread_getaffinity_np(pthread_t thread, size_t cpusetsize, cpu_set_t *cpuset);

Compile and link with -pthread.
```

# linux 系统里，一个被打开的文件可以被另一个进程删除吗？

linux是通过link的数量来控制文件删除，只有当一个文件不存在任何link的时候，这个文件才会被删除。

而每个文件都会有2个link计数器i_count 和 i_nlink。i_count的意义是当前使用者的数量，也就是打开文件进程的个数。i_nlink的意义是介质连接的数量；或者可以理解为 i_count是内存引用计数器，i_nlink是硬盘引用计数器。再换句话说，当文件被某个进程引用时，i_count 就会增加；当创建文件的硬连接的时候，i_nlink 就会增加。

对于 rm 而言，就是减少 i_nlink。这里就出现一个问题，如果一个文件正在被某个进程调用，而用户却执行 rm 操作把文件删除了，会出现什么结果呢？

当用户执行 rm 操作后，ls 或者其他文件管理命令不再能够找到这个文件，但是进程却依然在继续正常执行，依然能够从文件中正确的读取内容。这是因为，rm 操作只是将 i_nlink 置为 0 了；由于文件被进程引用的缘故，i_count 不为 0，所以系统没有真正删除这个文件。

简而言之：
- 如果当前文件不存在任何link 且没有被进程打开，这个文件就会被删除，空间也会被重新利用。
- 如果当前文件不存在任何link，但是仍然被某个进程打开，那么这个文件会被保留到最后一个文件描述符被关闭。


# 缓存更新策略
1. Cache Aside Pattern
    失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
    命中：应用程序从cache中取数据，取到后返回。
    更新：先把数据存到数据库中，成功后，再让缓存失效。

2. Read/Write Through Pattern
   从设计上看，Cache aside这个模式的缺点在于需要程序去维护两个不同的存储设备，（比如一个MySQL，一个Redis），硬编码的成本较大，而且容易出现编码失误，更好的方式是，提供特殊服务专门维护，将其与业务隔离开。
   1. Read Through
    Read Through 是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。
   2. Write Through
    Write Through 在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）

3. Write Behind Caching Pattern
    俗称write back，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比，因为异步（比如消息队列），write back还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。

    但是这个设计的最大致命问题在于数据的不强一致性，极可能造成数据的丢失。假如使用redis作为缓存数据库，最致命的问题在于redis并不能保证绝对不丢失数据，也就是redis的持久化能力（两种持久化都无法保证数据绝对丢失）不足，redis一旦挂了，可能造成数据丢失且无法恢复。

# 用户态和内核态

## 概念
内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。
用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

## 原因
由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, CPU划分出两个权限等级 -- 用户态和内核态。

用户态切换到内核态的3种方式：
1. 系统调用
2. 异常
3. 外围设备的中断 

## 工作流程
1. 应用程序通过调用C语言函数库中的外壳（wrapper）函数，来发起系统调用
2. 通过堆栈将这些参数传入外壳函数，外壳函数会将上述参数复制到寄存器
3. 外壳函数执行一条中断机器指令（int 0x80），引发处理器从用户态切换到核心态，并执行系统中断0x80的中断矢量所指向的代码
4. 为相应中断0x80，内核会调用system_call()例程来处理这次中断：
   1. 在内核栈中保存寄存器值
   2. 检查系统调用编号的有效性，根据编号对查找服务例程列表进行索引，发现并调用相应对服务例程
   3. 从内核栈中恢复各寄存器的值，并将系统调用返回值置于栈中
   4. 返回至外壳函数，同时将处理器切换回用户态
5. 如果有错，外壳函数会设置全局变量errno

## 详述
所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令。这种机制叫系统调用, 在CPU中的实现称之为陷阱指令(Trap Instruction)

内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。
Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。
至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。

# 用户线程 和 内核线程

## 用户线程
用户级线程是指不需要内核支持而在用户程序中实现的线程，它的内核的切换是由用户态程序自己控制内核的切换，不需要内核的干涉。但是它不能像内核级线程一样更好的运用多核CPU。
优点：
1. 线程的调度不需要内核直接参与，控制简单。
2. 可以在不支持线程的操作系统中实现。
3. 同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起，可以节约更多的系统资源。
缺点：
1. 一个用户级线程的阻塞将会引起整个进程的阻塞。
2. 用户级线程不能利用系统的多重处理，仅有一个用户级线程可以被执行。

## 内核线程
内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态。可以很好的运用多核CPU。
优点：
1. 当有多个处理机时，一个进程的多个线程可以同时执行。
2. 由于内核级线程只有很小的数据结构和堆栈，切换速度快，当然它本身也可以用多线程技术实现，提高系统的运行速率。

缺点：
1. 线程在用户态的运行，而线程的调度和管理在内核实现，在控制权从一个线程传送到另一个线程需要用户态到内核态再到用户态的模式切换，比较占用系统资源。（就是必须要受到内核的监控）

关联性：
1. 内核线程是OS内核可感知的，而用户级线程是OS内核不可感知的。也就是内核看不到用户级的线程，只能将其作为一个进程看待。
2. 用户级线程的创建、撤消和调度不需要OS内核的支持。
3. 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。
4. 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。
5. 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。

# 通用调度算法

1.  SCHED_OTHER：分时调度（time-sharing scheduling）策略，它是Linux线程默认的调度策略。SCHED_OTHER策略的静态优先级总是为0，对于该策略列表上的线 程，调度器是基于动态优先级（dynamic priority）来调度的，动态优先级是跟nice中相关(nice值可以由接口nice, setpriority,sched_setattr来设置)，该值会随着线程的运行时间而动态改变，以确保所有具有SCHED_OTHER策略的线程公平运行。
2.  SCHED_FIFO：先入先出调度策略（First in-first out scheduling）。
3.  SCHED_RR：时间片轮转调度(Round-robin scheduling)。

# 一个进程崩溃会不会影响其他进程，线程呢?

线程有自己的 stack，但是没有单独的 heap，也没有单独的 address space。
只有进程有自己的 address space，而这个 space 中经过合法申请的部分叫做 process space。Process space 之外的地址都是非法地址。当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。

进程与进程之间是完全隔离的,所以进程不受影响。

# 读者写者问题（读者优先、写者优先、公平竞争）

# 多线程怎么调试

- log
- assert
- core
- tcptrace

Linux 不允许生成 core dump 文件。下面的命令显示，Linux 允许的最大 core dump 文件大小为 0：
```sh
$ ulimit -a | grep core
core file size          (blocks, -c) 0
```
可以通过下面设置，允许 Linux 生成 core dump 文件：
```sh
$ ulimit -c unlimited
```

# 线程数量选择
- cpu密集型：
理论上线程数量=cpu核心数就行了，一个cpu核心执行一个线程，避免切换线程带来的消耗。
但是实际上会设置cpu逻辑核心数+1。因为某个线程发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。

- I/O密集型:
这种类型的程序执行时有很大部分时间是在I/O的消耗上，所以会导致cpu空闲时间较多。此时根据cpu核数计算线程数量就不合算了。

`最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * (1 + (I/O耗时/CPU耗时)) = CPU 核心数 *（1+平均等待时间/平均工作时间）`

cpu使用率获取
APM(Application Performance Manager)工具可以帮我们找到准确的数据
- SkyWalking
- CAT
- zipkin

# cache 和 buffer 的区别
1. Buffer（缓冲区）主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以**减少响应次数**。
2. Cache（缓存）为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到**加快访问速度**的作用。
3. 假定以后存储器访问变得跟CPU做计算一样快，cache就可以消失，但是buffer依然存在。比如从网络上下载东西，瞬时速率可能会有较大变化，但从长期来看却是稳定的，这样就能通过引入一个buffer使得OS接收数据的速率更稳定，进一步减少对磁盘的伤害。
4. TLB（Translation Lookaside Buffer，翻译后备缓冲器）名字起错了，其实它是一个cache.

# 操作系统之磁盘寻道调度算法
1. 先来先服务算法（FCFS）First Come First Service
2. 最短寻道时间优先算法（SSTF） Shortest Seek Time First
3. 扫描算法（SCAN）电梯调度
4. 循环扫描算法（CSCAN）

