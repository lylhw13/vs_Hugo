---
title: "Compiler"
date: 2020-09-03T15:36:50+08:00
draft: true
---

# chapter 1
compiler 编译器，输出可执行程序，属于离线方式 offline
interpreter 解释器，输出计算结果，属于在线方式 online

词法分析 -> 记号
语法分析 -> 抽象语法树
语义分析 
代码生成

AST 抽象语法树

后续遍历

栈式计算机 stack JVM


# chapter 2

字符流 -> 词法分析器 -> 记号流


正则表达式：
- 对给定的字符集 Σ = {c1, c2, ..., cn}
- 归纳定义：
  - 空串 ε 是正则表达式
  - 对于任意 c ∈ Σ，c是正则表达式
  - 如果 M 和 N 是正则表达式, 则以下也是正则表达式
    - 选择  M | N = {M, N}
    - 连接  MN = {mn| m∈M, n∈N}
    - 闭包  M* = {ε, M, MM, MMM, ...}（又叫做 Kleen 闭包）

语法糖，来简化构造：
- [c1-cn] == c1|c2|...|cn
- e+ == 一个或多个e
- e? == 零个或一个e
- "a*" == a* 自身，不是a的Kleen闭包
- e{i,j} == i到j个e的连接
- . == 除 '\n' 外的任意字符

语法糖不是必须，可以通过基本构造得到

仅仅两个操作就够：赋值和跳转



输入字符串 -> FA -> {Yes, No}

M = {Σ, S, q0, F, δ}

- Σ 字母表
- S 状态集
- q0 初始状态
- F 终结状态集
- δ 转移函数

有限状态自动机 FA

确定有限状态自动机 DFA ：
- 对于任意的字符，最多有一个状态可以转移
  - δ: S x Σ -> S

非确定状态自动机 NFA：
- 对于任意的字符，有多于一个状态可以转移
  - δ: S x (Σ U ε) -> P(S)  

幂集 P(S)

# chapter 3

RE -> NFA -> DFA -> 词法分析器代码

RE -> NFA 采用 Thompson算法

基于对RE的结构做归纳：
- 对基本的RE直接构造
- 对复合的RE递归构造


NFA -> DFA 采用 子集构造算法
- 不动点算法
- ε 闭包：可以基于深度优先和广度优先算法
- 

DFA -> 词法分析器代码 采用 Hopcroft 最小化算法
基于等价类的思想
转移表
跳转表 jump table

# chapter4

记号流 -> 语法分析器 -> 语法树

数学理论：上下文无关文法（CFG）
- 描述语言语法规则的数学工具
自顶向下分析
- 递归下降分析算法（预测分析算法）
- LL分析算法
自底向上分析
- LR分析算法

乔姆斯基文法体系
3 正则文法 2 上下文无关文法 1 有关文法 0 任意文法

3 用于词法分析
2 语言语法分析

上下文无关文法G是一个四元组：
G = {T, N, P, S}
- 其中T是终结符号集合
- N 是非终结符合集合
- P 是一组产生规则：
  - 每条规则的形式 X -> b1, b2 .. bn
    其中 X ∈ N, bi ∈ (T U N)
- S 是唯一的开始符号（非终结符）
  - S ∈ N

推导：
- 给定文法G，从G的开始符号S开始，用产生式的右部替换左侧的非终结符
- 此过程不断重复，直到不出现非终结符为止
- 最终的串称为句子

最左推导和最右推导
- 最左推导：每次总是选择最左侧的符号进行替换。

分析树的含义取决于树的后续遍历。

手动生成
从开始符号出发推出句子，称为自顶向下分析
- 递归下降分析

递归下降分析也称为预测分析，基本思想：
- 每个非终结符构造一个分析函数
- 用前看符号指导产生式规则的选择

# chapter 5

自顶向下分析算法
LL(1) 分析算法
不动点算法

任何左递归的文法都不是LL(1) 文法，有递归一般没有问题
消除左递归

自底向上分析算法
LR(0)
是最右推导的逆过程


由左侧到右侧叫替换
由右侧到左侧叫归约







