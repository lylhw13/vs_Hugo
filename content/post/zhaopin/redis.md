---
title: "Redis"
date: 2020-08-08T15:06:47+08:00
draft: true
---

redis 持久化有哪几种方式，怎么选？
redis 主从同步是怎样的过程？
redis 的 zset 怎么实现的？
redis key 的过期策略
redis 哨兵和集群
hashmap 是怎样实现的？

让你设计一个限流的系统怎么做？ 令牌桶
让你设计一个延时任务系统怎么做 说了两个方案，一个是使用 redis 的 ZSET 来实现，考虑分片来抗高并发，使用 redis 的持久化来实现落地，使用 redis 的哨兵实现故障转移。 一个是使用时间轮的方法。

# redis 数据结构
- string 
  - int, embstr, raw
- List
  - ziplist, linkerlist
- Hash
  - ziplist, HT
- Set
  - intset, HT
- Zset
  - ziplist, skiptlist

# redis 过期键删除策略
有三种基本的删除策略：
- 定时删除：设置定时器，让定时器在键过期时间来临时，立即执行对键对删除操作
- 惰性删除
- 定期删除：每隔一定时间删除

Redis 采用惰性删除和定期删除两种策略。

# redis内存回收
Redis中采用两种算法进行内存回收，引用计数算法以及LRU（least recently used）算法

# redis 主从同步
1. 从服务器向主服务器发送SYNC命令
2. 收到SYNC命令，主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
3. 主服务器发送RDB文件给从服务器，从服务器载入RDB文件，执行同步
4. 主服务器发送缓冲区的命令给从服务器。


# raft

Raft 主要被分成了领导人选举，日志复制和安全三个模块
通过实施一个更强的一致性来减少需要考虑的状态的数量

Raft 算法被我们分成领导人选举，日志复制，安全性和角色改变几个部分。

Raft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：

- 强领导者：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。
- 领导选举：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。
- 成员关系调整：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。



通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：

领导选举：一个新的领导人需要被选举出来，当现存的领导人宕机的时候（章节 5.2）
日志复制：领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。
安全性：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到一个额外的选举机制（5.2 节）上的限制。

任期在 Raft 算法中充当逻辑时钟的作用

基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节 5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。

每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。

Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。

在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。

领导人从来不会覆盖或者删除自己的日志

Raft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。
RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。

# 一致性hash
参考<https://juejin.im/post/6850418113830846471>

分布式数据存储时，需要数据分片，普通的分片方法是直接hash取模，根据机器数量取模就会存在一个问题，当机器不够用需要扩容或机器宕机，机器的数量就会发生变化，造成数据的命中率下降，所以之前的数据就需要重新hash做一次sharding。这种操作会导致服务在一定的时间不可用，而且每次扩缩容都会存在这个问题。

一致性hash算法主要应用于分布式存储系统中，可以有效地解决分布式存储结构下普通余数Hash算法带来的伸缩性差的问题，可以保证在动态增加和删除节点的情况下尽量有多的请求命中原来的机器节点。

原理说明：
- 一致性hash 对 2^32 取模，形成一个虚拟的环
- 对服务器，比如使用主机名进行 hash， 可以得到在环上的位置
- 对key-value数据进行hash，根据 key 在环上的位置，将数据存储在环上顺时针遇到的第一个服务器节点
    这样可以保证在一个节点失效的时候，只有该节点上游的数据受影响，其他数据不受影响

可能的问题：数据倾斜
如果服务器太少，，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题

为了解决数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在主机名的后面增加编号来实现。