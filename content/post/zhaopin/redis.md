---
title: "Redis"
date: 2020-08-08T15:06:47+08:00
draft: true
---

redis 持久化有哪几种方式，怎么选？
redis 主从同步是怎样的过程？
redis 的 zset 怎么实现的？
redis key 的过期策略
redis 哨兵和集群
hashmap 是怎样实现的？

让你设计一个限流的系统怎么做？ 令牌桶
让你设计一个延时任务系统怎么做 说了两个方案，一个是使用 redis 的 ZSET 来实现，考虑分片来抗高并发，使用 redis 的持久化来实现落地，使用 redis 的哨兵实现故障转移。 一个是使用时间轮的方法。

# redis 过期键删除策略
有三种基本的删除策略：
- 定时删除：设置定时器，让定时器在键过期时间来临时，立即执行对键对删除操作
- 惰性删除
- 定期删除：每隔一定时间删除

Redis 采用惰性删除和定期删除两种策略。

# redis内存回收
Redis中采用两种算法进行内存回收，引用计数算法以及LRU（Least Re）算法

# redis 主从同步
1. 从服务器向主服务器发送SYNC命令
2. 收到SYNC命令，主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
3. 主服务器发送RDB文件给从服务器，从服务器载入RDB文件，执行同步
4. 主服务器发送缓冲区的命令给从服务器。


# raft

Raft 主要被分成了领导人选举，日志复制和安全三个模块
通过实施一个更强的一致性来减少需要考虑的状态的数量

Raft 算法被我们分成领导人选举，日志复制，安全性和角色改变几个部分。

Raft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：

- 强领导者：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。
- 领导选举：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。
- 成员关系调整：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。



通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：

领导选举：一个新的领导人需要被选举出来，当现存的领导人宕机的时候（章节 5.2）
日志复制：领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。
安全性：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到一个额外的选举机制（5.2 节）上的限制。

任期在 Raft 算法中充当逻辑时钟的作用

基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节 5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。

每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。

Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。

在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。

领导人从来不会覆盖或者删除自己的日志

Raft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。
RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。
